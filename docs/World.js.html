

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: World.js</title>

    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./build/entry.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
    <link type="text/css" rel="stylesheet" href="styles/iframe.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    
                    
                        <h1 class="navbar-item">Documentation</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Anvil.html">Anvil</a></li><li><a href="BankChest.html">BankChest</a></li><li><a href="Board.html">Board</a></li><li><a href="Boss.html">Boss</a></li><li><a href="Breakable.html">Breakable</a></li><li><a href="Buildable.html">Buildable</a></li><li><a href="Character.html">Character</a></li><li><a href="CraftingStation.html">CraftingStation</a></li><li><a href="Destroyable.html">Destroyable</a></li><li><a href="Dungeon.html">Dungeon</a></li><li><a href="DungeonPortal.html">DungeonPortal</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Entrance.html">Entrance</a></li><li><a href="Exit.html">Exit</a></li><li><a href="Furnace.html">Furnace</a></li><li><a href="GreatGnarl.html">GreatGnarl</a></li><li><a href="GroundTile.html">GroundTile</a></li><li><a href="Interactable.html">Interactable</a></li><li><a href="Item.html">Item</a></li><li><a href="Laboratory.html">Laboratory</a></li><li><a href="MagicEffect.html">MagicEffect</a></li><li><a href="MasterAssassin.html">MasterAssassin</a></li><li><a href="MetalDoor.html">MetalDoor</a></li><li><a href="Mob.html">Mob</a></li><li><a href="NewTask.html">NewTask</a></li><li><a href="OverworldPortal.html">OverworldPortal</a></li><li><a href="Pickup.html">Pickup</a></li><li><a href="Player.html">Player</a></li><li><a href="Projectile.html">Projectile</a></li><li><a href="ShopClan.html">ShopClan</a></li><li><a href="ShopNPC.html">ShopNPC</a></li><li><a href="Spawner.html">Spawner</a></li><li><a href="SpawnerArea.html">SpawnerArea</a></li><li><a href="SpawnerTotem.html">SpawnerTotem</a></li><li><a href="Stat.html">Stat</a></li><li><a href="Static.html">Static</a></li><li><a href="Statset.html">Statset</a></li><li><a href="StatusEffect.html">StatusEffect</a></li><li><a href="Task.html">Task</a></li><li><a href="Taskset.html">Taskset</a></li><li><a href="TaskType.html">TaskType</a></li><li><a href="WoodDoor.html">WoodDoor</a></li><li><a href="WoodDoorLockedBlue.html">WoodDoorLockedBlue</a></li><li><a href="WoodDoorLockedGreen.html">WoodDoorLockedGreen</a></li><li><a href="WoodDoorLockedRed.html">WoodDoorLockedRed</a></li><li><a href="WoodDoorLockedYellow.html">WoodDoorLockedYellow</a></li><li><a href="Workbench.html">Workbench</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#MobStatsList">MobStatsList</a></li><li><a href="global.html#RewardsList">RewardsList</a></li><li><a href="global.html#sendEvent">sendEvent</a></li><li><a href="global.html#taskType">taskType</a></li></ul></div><div class="category"><h2>Corpse</h2><h3>Classes</h3><ul><li><a href="CorpseHuman.html">CorpseHuman</a></li></ul></div><div class="category"><h2>Mob</h2><h3>Classes</h3><ul><li><a href="ArchMage.html">ArchMage</a></li><li><a href="Assassin.html">Assassin</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>World.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const wss = require('./Server');
const Utils = require('./Utils');
const AccountManager = require('./AccountManager');
const clanManager = require('./ClanManager');
const Dungeon = require('./Dungeon');
const EventsList = require('./EventsList');
const BoardsList = require('./BoardsList');
const DayPhases = require('./DayPhases');
const dayPhaseCycle = [
    DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day, DayPhases.Day,
    DayPhases.Dusk,
    DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night, DayPhases.Night,
    DayPhases.Dawn
];
const dayPhaseRate = (60000 * 24) / dayPhaseCycle.length;

const world = {

    accountManager: AccountManager,

    playerCount: 0,

    maxPlayers: 1000,

    /** @type {Board[]} */
    boardsArray: BoardsList.boardsArray,

    boardsObject: BoardsList.boardsObject,

    // Gameplay stuff.
    dayPhase: DayPhases.Day,

    init() {
        const fs = require('fs');
        const dirs = fs.readdirSync('map', {encoding: 'utf-8', withFileTypes: true});
        const path = require('path');

        dirs.forEach((elem) => {
            const parsed = path.parse(elem.name);
            // Skip the blank template map.
            if(parsed.name === "BLANK") return;
            
            // Only load JSON map data.
            if(parsed.ext === ".json"){
                this.loadBoard(parsed.name);
            }

        });
        
        // Load the clans into the game world after the boards are
        // created, or there will be nothing to add the structures to.
        //clanManager.loadDataFromFile();

        // Wire up all of the exits to the entrances of each board.
        // Need to do this after the boards have been created, otherwise
        // there might be nothing to link to while the exits are being created.
        this.linkExits();

        // Start the day/night cycle loop.
        //setTimeout(world.progressTime, dayPhaseRate);
    },

    /**
     * @param {String} dataFileName - The end part of the URL to the map data file.
     */
    loadBoard(dataFileName) {
        const data = require('../map/' + dataFileName + '.json');

        const mapProperties = Utils.arrayToObject(data.properties, 'name', 'value');

        // Skip disabled maps.
        if(mapProperties['Disabled'] === true) {
            console.log("* Skipping disabled map:", dataFileName);
            return;
        }
        
        let alwaysNight = false;
        if(mapProperties['AlwaysNight'] == undefined) Utils.warning("Map data is missing property: 'AlwaysNight'. On map: " + dataFileName);
        if(mapProperties['AlwaysNight'] === true) alwaysNight = true;

        let isDungeon = false;
        if(mapProperties['IsDungeon'] == undefined) Utils.warning("Map data is missing property: 'IsDungeon'. On map: " + dataFileName);
        if(mapProperties['IsDungeon'] === true){
            if(!mapProperties['Difficulty']) Utils.warning("Dungeon map is missing property: 'Difficulty'. Using default. On map: " + dataFileName);
            if(!mapProperties['NameDefinitionID']) Utils.warning("Dungeon map is missing property: 'NameDefinitionID'. Using default. On map: " + dataFileName);
            isDungeon = true;
            
            new Dungeon(dataFileName, mapProperties['NameDefinitionID'], mapProperties['Difficulty']);
        }
        const board = new Board(data, dataFileName, alwaysNight, isDungeon);
        if(board.alwaysNight === false){
            board.dayPhase = this.dayPhase;
        }

        this.boardsArray.push(board);
        this.boardsObject[dataFileName] = board;

        //console.log("* Board loaded:", dataFileName);
    },

    linkExits() {
        //console.log("linking exits");
        let board,
            row,
            rowLen,
            col,
            colLen,
            exit;

        // For each board.
        for(let i=0, boardsLen=this.boardsArray.length; i&lt;boardsLen; i+=1){
            board = this.boardsArray[i];
            // For each row in the board grid.
            for(row=0, rowLen=board.grid.length; row&lt;rowLen; row+=1){
                // For each column in that row.
                for(col=0, colLen=board.grid[row].length; col&lt;colLen; col+=1){
                    // Check if the static is an exit.
                    if(board.grid[row][col].static instanceof Exit){
                        exit = board.grid[row][col].static;
                        // If the target for this exit isn't valid (might have been removed from the map), then destroy this exit.
                        if(this.boardsObject[exit.targetBoard] === undefined){
                            exit.destroy();
                            continue;
                        }
                        if(this.boardsObject[exit.targetBoard].entrances[exit.targetEntrance] === undefined){
                            exit.destroy();
                            continue;
                        }
                        // Currently, the exits have the string name of the board and entrance they should
                        // use in place of the actual objects, which are now used to set the actual objects.
                        exit.targetBoard = this.boardsObject[exit.targetBoard];
                        exit.targetEntrance = exit.targetBoard.entrances[exit.targetEntrance];
                    }
                }
            }
        }
    },

    /**
     * Add a player entity to the game world from an existing player account.
     * @param {Object} clientSocket
     * @param {AccountModel} account
     */
    addExistingPlayer(clientSocket, account) {

        console.log("* World add existing player:", account.displayName);

        if(clientSocket.entity !== undefined){
            // Weird bug... :S
            Utils.warning("* * * * * adding existing player, but client socket already has an entity");
        }

        // Don't let too many players in the world.
        if(world.playerCount &lt; world.maxPlayers){
            // Start them in the overworld if they have played before.
            const randomPosition = world.boardsObject['overworld'].entrances['city-spawn'].getRandomPosition();

            /** @type {Player} */
            const playerEntity = new EntitiesList.Player({
                row: randomPosition.row,
                col: randomPosition.col,
                board: world.boardsObject["overworld"],
                displayName: account.displayName,
                socket: clientSocket,
            });

            AccountManager.loadPlayerData(playerEntity, account);

            const dataToSend = {};

            // Add the extra properties for the loaded data.
            dataToSend.isLoggedIn = true;
            dataToSend.inventory = playerEntity.getEmittableInventory();
            dataToSend.bankItems = playerEntity.bankAccount.getEmittableItems();
            dataToSend.boardName = playerEntity.board.name;
            dataToSend.boardAlwaysNight = playerEntity.board.alwaysNight;
            dataToSend.dayPhase = playerEntity.board.dayPhase;
            dataToSend.player = {
                id: playerEntity.id,
                row: playerEntity.row,
                col: playerEntity.col,
                displayName: playerEntity.displayName,
                maxHitPoints: playerEntity.maxHitPoints,
                maxEnergy: playerEntity.maxEnergy,
                glory: playerEntity.glory,
                stats: playerEntity.stats.getEmittableStats(),
                tasks: playerEntity.tasks.getEmittableTasks(),
            };
            // Get the things this player can see.
            dataToSend.dynamicsData = playerEntity.board.getNearbyDynamicsData(playerEntity.row, playerEntity.col);

            // Tell the nearby players to add this new player, after they are full set up (if an account was loaded, the properties will have been modified after object creation).
            playerEntity.emitToNearbyPlayers();

            clientSocket.sendEvent(EventsList.join_world_success, dataToSend);

            clientSocket.inGame = true;

            world.playerCount += 1;
        }
        else {
            clientSocket.sendEvent(EventsList.world_full);
        }

        console.log("  * Player count:", this.playerCount);
    },

    /**
     * Add a new player entity to the game world, without an associated player account.
     * They can create an account to associate with later.
     * @param {Object} clientSocket
     * @param {String} displayName
     */
    addNewPlayer(clientSocket, displayName) {

        if(clientSocket.entity !== undefined){
            // Weird bug... :S
            Utils.warning("* * * * adding new player, but client socket already has an entity");
        }

        console.log("* World add new player:", displayName);

        // Don't let too many players in the world.
        if(world.playerCount &lt; world.maxPlayers){

            const randomPosition = world.boardsObject['tutorial'].entrances['spawn'].getRandomPosition();

            /** @type {Player} */
            const playerEntity = new EntitiesList.Player({
                row: randomPosition.row,
                col: randomPosition.col,
                board: world.boardsObject["tutorial"],
                displayName: displayName,
                socket: clientSocket
            });

            // Give the new player some starting tasks, as they are NOT added automatically for player entities.
            playerEntity.tasks.addStartingTasks();
            // New accounts get some free stuff in their bank in the tutorial, so add those properties.
            playerEntity.bankAccount.addStarterItems();

            const dataToSend = {};

            dataToSend.inventory = playerEntity.getEmittableInventory();
            dataToSend.bankItems = playerEntity.bankAccount.getEmittableItems();
            dataToSend.boardName = playerEntity.board.name;
            dataToSend.boardAlwaysNight = playerEntity.board.alwaysNight;
            dataToSend.dayPhase = playerEntity.board.dayPhase;
            dataToSend.player = {
                id: playerEntity.id,
                row: playerEntity.row,
                col: playerEntity.col,
                displayName: playerEntity.displayName,
                maxHitPoints: playerEntity.maxHitPoints,
                maxEnergy: playerEntity.maxEnergy,
                glory: playerEntity.glory,
                stats: playerEntity.stats.getEmittableStats(),
                tasks: playerEntity.tasks.getEmittableTasks(),
            };
            // Get the things this player can see.
            dataToSend.dynamicsData = playerEntity.board.getNearbyDynamicsData(playerEntity.row, playerEntity.col);

            // Tell the nearby players to add this new player, after they are full set up (if an account was loaded, the properties will have been modified after object creation).
            playerEntity.emitToNearbyPlayers();

            clientSocket.sendEvent(EventsList.join_world_success, dataToSend);

            clientSocket.inGame = true;

            world.playerCount += 1;
        }
        else {
            clientSocket.sendEvent(EventsList.world_full);
        }

        console.log("  * Player count:", this.playerCount);
    },

    /**
     * Remove the given player from the world and the game.
     * @param {Object} clientSocket - The socket of the player entity to remove.
     */
    removePlayer(clientSocket) {
        console.log("remove player, account username:", clientSocket.accountUsername);
        // If the socket had an entity, remove it from the game.
        if(clientSocket.entity !== undefined){
            // If they have an account username then they have an account, so log them out.
            if(clientSocket.accountUsername){
                AccountManager.logOut(clientSocket);
            }

            clientSocket.entity.remove();
            // Remove the reference to the player entity.
            delete clientSocket.entity;
        }
        clientSocket.inGame = false;
        // Reduce the player count.
        this.playerCount -= 1;

        console.log("* World remove player, player count:", this.playerCount);
    },

    /**
     * Move the game day phase along one phase.
     */
    progressTime() {
        // Shuffle the time along to the next period.
        dayPhaseCycle.push(dayPhaseCycle.shift());

        //console.log("* Day phase progressed:", dayPhaseCycle[0]);

        // Check if the period is different than last. Don't bother updating the boards/players if it is the same. i.e. day and night last more than one phase.
        if(dayPhaseCycle[0] !== world.dayPhase){
            // Get whatever is at the front.
            world.dayPhase = dayPhaseCycle[0];

            for(let i=0, len=BoardsList.boardsArray.length; i&lt;len; i+=1){
                // Don't change the time inside dungeons and caves etc. They are always dark (night).
                if(BoardsList.boardsArray[i].alwaysNight === false){
                    BoardsList.boardsArray[i].dayPhase = world.dayPhase;
                }
            }

            // Tell the boards and everyone on them the time has changed.
            wss.broadcastToInGame(EventsList.change_day_phase, world.dayPhase);
        }

        setTimeout(world.progressTime, dayPhaseRate);
    }

};

module.exports = world;

// Import these AFTER the world is exported.
const Board = require('./Board');
const EntitiesList = require('./EntitiesList');
const Exit = require('./entities/statics/interactables/exits/Exit');</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>


<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Sat Jan 25 2020 01:23:46 GMT+0000 (Greenwich Mean Time)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
        </p>
    </div>
</footer>


<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
