

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: AccountManager.js</title>

    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./build/entry.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
    <link type="text/css" rel="stylesheet" href="styles/iframe.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    
                    
                        <h1 class="navbar-item">Documentation</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Anvil.html">Anvil</a></li><li><a href="BankChest.html">BankChest</a></li><li><a href="Board.html">Board</a></li><li><a href="Boss.html">Boss</a></li><li><a href="Breakable.html">Breakable</a></li><li><a href="Buildable.html">Buildable</a></li><li><a href="Character.html">Character</a></li><li><a href="CraftingStation.html">CraftingStation</a></li><li><a href="Destroyable.html">Destroyable</a></li><li><a href="Dungeon.html">Dungeon</a></li><li><a href="DungeonPortal.html">DungeonPortal</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Entrance.html">Entrance</a></li><li><a href="Exit.html">Exit</a></li><li><a href="Furnace.html">Furnace</a></li><li><a href="GreatGnarl.html">GreatGnarl</a></li><li><a href="GroundTile.html">GroundTile</a></li><li><a href="Interactable.html">Interactable</a></li><li><a href="Item.html">Item</a></li><li><a href="Laboratory.html">Laboratory</a></li><li><a href="MagicEffect.html">MagicEffect</a></li><li><a href="MasterAssassin.html">MasterAssassin</a></li><li><a href="MetalDoor.html">MetalDoor</a></li><li><a href="Mob.html">Mob</a></li><li><a href="NewTask.html">NewTask</a></li><li><a href="OverworldPortal.html">OverworldPortal</a></li><li><a href="Pickup.html">Pickup</a></li><li><a href="Player.html">Player</a></li><li><a href="Projectile.html">Projectile</a></li><li><a href="ShopClan.html">ShopClan</a></li><li><a href="ShopNPC.html">ShopNPC</a></li><li><a href="Spawner.html">Spawner</a></li><li><a href="SpawnerArea.html">SpawnerArea</a></li><li><a href="SpawnerTotem.html">SpawnerTotem</a></li><li><a href="Stat.html">Stat</a></li><li><a href="Static.html">Static</a></li><li><a href="Statset.html">Statset</a></li><li><a href="StatusEffect.html">StatusEffect</a></li><li><a href="Task.html">Task</a></li><li><a href="Taskset.html">Taskset</a></li><li><a href="TaskType.html">TaskType</a></li><li><a href="WoodDoor.html">WoodDoor</a></li><li><a href="WoodDoorLockedBlue.html">WoodDoorLockedBlue</a></li><li><a href="WoodDoorLockedGreen.html">WoodDoorLockedGreen</a></li><li><a href="WoodDoorLockedRed.html">WoodDoorLockedRed</a></li><li><a href="WoodDoorLockedYellow.html">WoodDoorLockedYellow</a></li><li><a href="Workbench.html">Workbench</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#MobStatsList">MobStatsList</a></li><li><a href="global.html#RewardsList">RewardsList</a></li><li><a href="global.html#sendEvent">sendEvent</a></li><li><a href="global.html#taskType">taskType</a></li></ul></div><div class="category"><h2>Corpse</h2><h3>Classes</h3><ul><li><a href="CorpseHuman.html">CorpseHuman</a></li></ul></div><div class="category"><h2>Mob</h2><h3>Classes</h3><ul><li><a href="ArchMage.html">ArchMage</a></li><li><a href="Assassin.html">Assassin</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>AccountManager.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
/**
 * @typedef {Function} AccountModel
 *
 * @property {String} username
 * @property {String} password
 * @property {Date} lastLogOutTime
 * @property {Boolean} isLoggedIn
 * @property {String} displayName
 * @property {Number} glory
 * @property {Array} bankItems
 * @property {Object} inventory
 * @property {Object} stats
 * @property {Object} tasks
 *
 * @param {Object} config
 */
let AccountModel;

const isSetup = false;

module.exports = {

    isShutDown: false,

    async setup() {
        // Setup should only happen once.
        if(isSetup === true){
            Utils.warning("Attempt to setup account manager again.");
            process.exit();
            return;
        }

        this.mongoose = require('mongoose');

        await this.mongoose.connect('mongodb://localhost/accounts', {useNewUrlParser: true, useUnifiedTopology: true, useCreateIndex: true})
            .catch((err) => {
                console.log("DB connect error:", err);
            });

        this.mongoose.connection.on('error', (err) => {
            console.error('DB connection error:', err);
            // Cannot connect to database, stop server init.
            process.exit();
        });

        const accountSchema = new this.mongoose.Schema({
            username:       {type: String,  required: true},
            password:       {type: String,  required: true},
            creationTime:   {type: Date,    default: Date.now()},
            lastLogOutTime: {type: Date,    default: Date.now()},
            isLoggedIn:     {type: Boolean, default: false},
            displayName:    {type: String,  default: "Savage"},
            glory:          {type: Number,  default: 0},
            bankItems:      {type: Array,   default: []},
            inventory:      {type: Object,  default: {}},
            stats:          {type: Object,  default: {}},
            tasks:          {type: Object,  default: {}},
        });
        // Create a unique index in the DB for the account username.
        accountSchema.index( 'username', {unique: true} );

        AccountModel = this.mongoose.model('Account', accountSchema);

        AccountModel.ensureIndexes(function (err) {
            if (err) return console.error(err);
        });

        AccountModel.on('index', function(res, error) {
            // "_id index cannot be sparse"
            console.log("DB index res:", res);
            console.log("DB index error:", error);
        });

        // Testing document.
        // const newAcc = new AccountModel({
        //     username: "",
        //     displayName: "",
        //     password: ""
        // });
        //
        // newAcc.save();

        // Log out all of the accounts, in case they were logged in the last time the server shut down,
        // otherwise some players will not be able to log in as their accounts are already logged in.
        await AccountModel.updateMany({}, {isLoggedIn: false});

    },

    /**
     *
     * @param {String} username
     * @param {String} password
     * @param {Player} entity
     * @param {Function} onSuccess
     * @param {Function} onFailure
     * @returns {Promise&lt;void>}
     */
    async createAccount(username, password, entity, onSuccess, onFailure) {

        const formattedData = this.getFormattedSaveData(entity);

        const acc = new AccountModel({
            username: username,
            password: password,
            isLoggedIn: true,
            displayName: formattedData.displayName,
            glory: formattedData.glory,
            bankItems: formattedData.bankItems,
            inventory: formattedData.inventory,
            stats: formattedData.stats,
            tasks: formattedData.tasks
        });

        await acc.save()
            .then((res) => {
                onSuccess();
            })
            .catch((err) => {
                if(err) {
                    // An index with this key (the username) already exists. Must be unique.
                    if(err.code === 11000){
                        // Username already taken.
                        onFailure();
                        return;
                    }
                }
                console.log("* Account manager, create account error:", err);
            })
    },

    /**
     * Log a player account in.
     * @param {Object} clientSocket
     * @param {String} username
     * @param {String} password
     * @param {Function} onSuccess
     */
    logIn(clientSocket, username, password, onSuccess) {
        AccountModel.findOne({username: username})
            .then(async (res) => {
                // If a document by the given username was NOT found, res will be null.
                if(!res) return;

                // Prevent them from logging into an account that is already logged in.
                if(res.isLoggedIn === true){
                    clientSocket.sendEvent(EventsList.something_went_wrong);
                    return;
                }

                if(res.password === password) {
                    // Success.
                    res.isLoggedIn = true;

                    await res.save();

                    onSuccess(res);
                }
                // Password is incorrect.
                else {
                    clientSocket.sendEvent(EventsList.invalid_login_details);
                }
            })
            .catch((err) => {
                console.log("* Account manager, log in error:", err);
                // Failure.
                clientSocket.sendEvent(EventsList.something_went_wrong);
            });
    },

    /**
     * Updates the data of an account in the accounts DB.
     * Happens when a player logs out or closes the game.
     * @param {Object} clientSocket
     */
    async logOut(clientSocket) {
        if(!clientSocket) return;
        if(!clientSocket.entity) return;
        if(!clientSocket.accountUsername) return;

        const formattedData = this.getFormattedSaveData(clientSocket.entity);

        await AccountModel.findOne({username: clientSocket.accountUsername})
            .then(async (res) => {
                // If a document by the given username was NOT found, res will be null.
                if(!res) return;

                res.lastLogOutTime = Date.now();
                res.isLoggedIn = false;
                res.displayName = formattedData.displayName;
                res.glory = formattedData.glory;
                res.bankItems = formattedData.bankItems;
                res.inventory = formattedData.inventory;
                res.stats = formattedData.stats;
                res.tasks = formattedData.tasks;

                await res.save();
            })
            .catch((err) => {
                console.log("* Account manager, log out error:", err);
                // Failure.
                clientSocket.sendEvent(EventsList.something_went_wrong);
            });
    },

    /**
     * Load the data from the given account into the entity of the player.
     * @param {Player} entity
     * @param {AccountModel} account
     */
    loadPlayerData(entity, account) {
        entity.displayName = account.displayName;
        // Round down, in case they were somehow decimals.
        entity.glory = Math.floor(account.glory);

        // Bank.
        const bankItems = account.bankItems;
        for(let i=0, len=bankItems.length; i&lt;len; i+=1){
            // Check the type of item to add is valid. Might have been removed (or renamed) since this player last logged in. Also checks for null.
            if(ItemsList[bankItems[i].itemTypeName] === undefined){
                continue;
            }

            entity.bankAccount.addItemToBankAccount(
                i,
                ItemsList[bankItems[i].itemTypeName], // BankAccount.addItemToBankAccount wants the TYPE itself, not just the type name.
                bankItems[i].durability,
                bankItems[i].maxDurability
            );
        }

        // Inventory.
        const inventory = account.inventory;
        for(let slotKey in inventory){
            if(inventory.hasOwnProperty(slotKey) === false) continue;
            // Check the type of item to add is valid. Might have been removed (or renamed) since this player last logged in. Also checks for null.
            if(ItemsList[inventory[slotKey].itemTypeName] === undefined) continue;

            entity.addToInventory(new ItemsList[inventory[slotKey].itemTypeName]({
                durability: inventory[slotKey].durability,
                maxDurability: inventory[slotKey].maxDurability
            }));
        }

        // Stats exp.
        const statsExp = account.stats;
        for(let statKey in entity.stats){
            if(entity.stats.hasOwnProperty(statKey) === false) continue;
            // Check the account has exp data on that stat. A new stat might have been added to
            // the stat set since this player last logged in, so they won't have an entry for it.
            if(statsExp[statKey] === undefined) continue;
            // Get the exp for each stat that this account has data on.
            entity.stats[statKey].exp = statsExp[statKey];
            entity.stats[statKey].calculateCurrentLevel();
        }

        // Tasks.
        // Catch the case that no existing task progresses were loaded successfully, so they at least have the starting ones.
        let addStartingTasks = true;
        const savedTasks = account.tasks;

        for(let savedTaskKey in savedTasks){
            if(savedTasks.hasOwnProperty(savedTaskKey) === false) continue;
            // Check the type of task to add is valid. Might have been removed (or renamed) since this player last logged in.
            if(TaskTypes[savedTaskKey] === undefined) continue;

            const taskData = savedTasks[savedTaskKey];
            // Check the task has a list of reward item types. Might be malformed data.
            if(taskData.rewardItemTypeNames === undefined) continue;
            const rewardItemTypes = [];
            for(let i=0; i&lt;taskData.rewardItemTypeNames.length; i+=1){
                // Check the item to add still exists. Might have been removed (or renamed) since this player last logged in.
                if(ItemsList[taskData.rewardItemTypeNames[i] === undefined]) continue;
                rewardItemTypes.push(ItemsList[taskData.rewardItemTypeNames[i]]);
            }

            new Task.Task(entity, TaskTypes[savedTaskKey], taskData.progress, taskData.completionThreshold, rewardItemTypes, taskData.rewardGlory);

            // Assume everything is ok.
            addStartingTasks = false;
        }

        // If they don't have enough tasks for whatever reason, give them the starting ones.
        if(Object.keys(entity.tasks.list).length &lt; 6){
            addStartingTasks = true;
        }

        // The owner has no task progress so far, give them the starting tasks.
        if(addStartingTasks === true) entity.tasks.addStartingTasks();
    },

    /**
     * Log out all player accounts that are currently logged in.
     * Called on server shut down, either intentionally (restart for update) or crash.
     * This will write the savable data of all connected players to a temporary local
     * file, as DB writes (which are async) cannot finish after process exit.
     * That local store of player data is then used to update the DB in a new process,
     * where it should be deleted if all of the updates were successful.
     * @param {Object} wss
     */
    saveAllPlayersData(wss) {
        const dataToSave = [];
        // Each connected client.
        for(let clientSocket of wss.clients){
            // Skip clients that are not yet fully connected.
            if(clientSocket.readyState !== 1) return;
            // Skip clients that are not in game.
            if(clientSocket.inGame === false) return;
            // Only log out clients that have an account username set.
            if(clientSocket.accountUsername){
                const playerData = this.getFormattedSaveData(clientSocket.entity);
                // Add the username of the account this data belongs to, so the
                // dump handler can find their document in the accounts DB.
                playerData.accountUsername = clientSocket.accountUsername;

                dataToSave.push(playerData);
            }
        }

        try {
            // Write the data to a temporary local file.

            // TODO: potential problem here where if there is a problem in PlayerDataDumpHandler
            //  and so the temp data isn't deleted, but then the server starts again and closes
            //  again, so will overwrite this existing temp file from last time.
            fs.writeFileSync('./PlayerDataDump.json', JSON.stringify(dataToSave));

            // Create a new process
            const spawn = require('child_process').spawn;
            const child = spawn('node', ['./PlayerDataDumpHandler.js'], {
                shell: true,
                detached: true // Decouple the new process from the this one, so it can keep running after this one closes.
            });

            child.unref();

        } catch (err) {
            console.log('Error writing PlayerDataDump.json:' + err.message);
        }

        console.log("* Logged in players account data saved.");
    },

    /**
     * Creates an object with all of the relevant data from a player entity to be saved in the Accounts DB.
     * @param {Player} entity
     * @returns {Object} The formatted data object.
     */
    getFormattedSaveData(entity) {
        /**
         * DO NOT SAVE TYPE NUMBERS OF ANY KIND, AS THEY WILL CHANGE BETWEEN BUILDS AS THINGS ARE ADDED.
         * Type names are fine. i.e. "ItemIronSword"
         */
        const data = {};

        data.displayName = entity.displayName || 'Savage';

        data.glory = entity.glory;

        // Bank.
        data.bankItems = [];
        const bankItems = entity.bankAccount.items;
        for(let i=0, len=bankItems.length; i&lt;len; i+=1){
            data.bankItems[i] = {
                // Item type name.
                itemTypeName: bankItems[i].itemTypeName,
                // Durability.
                durability: bankItems[i].durability,
                // Max durability.
                maxDurability: bankItems[i].maxDurability
            };
        }

        // Inventory.
        data.inventory = {};
        for(let slotKey in entity.inventory){
            if(entity.inventory.hasOwnProperty(slotKey) === false) continue;
            // Skip empty (null) slots.
            if(entity.inventory[slotKey] === null) continue;
            data.inventory[slotKey] = {
                // Item type name.
                itemTypeName: entity.inventory[slotKey].constructor.name,
                // Durability.
                durability: entity.inventory[slotKey].durability,
                // Max durability.
                maxDurability: entity.inventory[slotKey].maxDurability
            }
        }

        // Stats exp.
        data.stats = {};
        for(let statKey in entity.stats){
            if(entity.stats.hasOwnProperty(statKey) === false) continue;
            data.stats[statKey] = entity.stats[statKey].exp;
        }

        // Tasks.
        data.tasks = {};
        const tasksList = entity.tasks.list;
        for(let taskKey in tasksList){
            if(tasksList.hasOwnProperty(taskKey) === false) continue;
            /** @type {Task} */
            const task = tasksList[taskKey];
            const itemTypes = [];
            // Can't save the class references, so save the class names.
            for(let i=0; i&lt;task.rewardItemTypes.length; i+=1){
                itemTypes.push(task.rewardItemTypes[i].name);
            }
            data.tasks[taskKey] = {
                taskID: task.taskType.taskID,
                progress: task.progress,
                completionThreshold: task.completionThreshold,
                rewardGlory: task.rewardGlory,
                rewardItemTypeNames: itemTypes,
            };
        }

        return data;
    }
};

const ItemsList = require('./ItemsList');
const Task = require('./tasks/Task');
const TaskTypes = require('./tasks/TaskTypes');
const EventsList = require('./EventsList');
const Utils = require('./Utils');
const fs = require('fs');</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>


<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Sat Jan 25 2020 01:23:46 GMT+0000 (Greenwich Mean Time)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
        </p>
    </div>
</footer>


<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
