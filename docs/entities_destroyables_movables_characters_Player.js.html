

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: entities/destroyables/movables/characters/Player.js</title>

    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./build/entry.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
    <link type="text/css" rel="stylesheet" href="styles/iframe.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    
                    
                        <h1 class="navbar-item">Documentation</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Anvil.html">Anvil</a></li><li><a href="BankChest.html">BankChest</a></li><li><a href="Board.html">Board</a></li><li><a href="Boss.html">Boss</a></li><li><a href="Breakable.html">Breakable</a></li><li><a href="Buildable.html">Buildable</a></li><li><a href="Character.html">Character</a></li><li><a href="CraftingStation.html">CraftingStation</a></li><li><a href="Destroyable.html">Destroyable</a></li><li><a href="Dungeon.html">Dungeon</a></li><li><a href="DungeonPortal.html">DungeonPortal</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Entrance.html">Entrance</a></li><li><a href="Exit.html">Exit</a></li><li><a href="Furnace.html">Furnace</a></li><li><a href="GreatGnarl.html">GreatGnarl</a></li><li><a href="GroundTile.html">GroundTile</a></li><li><a href="Interactable.html">Interactable</a></li><li><a href="Item.html">Item</a></li><li><a href="Laboratory.html">Laboratory</a></li><li><a href="MagicEffect.html">MagicEffect</a></li><li><a href="MasterAssassin.html">MasterAssassin</a></li><li><a href="MetalDoor.html">MetalDoor</a></li><li><a href="Mob.html">Mob</a></li><li><a href="NewTask.html">NewTask</a></li><li><a href="OverworldPortal.html">OverworldPortal</a></li><li><a href="Pickup.html">Pickup</a></li><li><a href="Player.html">Player</a></li><li><a href="Projectile.html">Projectile</a></li><li><a href="ShopClan.html">ShopClan</a></li><li><a href="ShopNPC.html">ShopNPC</a></li><li><a href="Spawner.html">Spawner</a></li><li><a href="SpawnerArea.html">SpawnerArea</a></li><li><a href="SpawnerTotem.html">SpawnerTotem</a></li><li><a href="Stat.html">Stat</a></li><li><a href="Static.html">Static</a></li><li><a href="Statset.html">Statset</a></li><li><a href="StatusEffect.html">StatusEffect</a></li><li><a href="Task.html">Task</a></li><li><a href="Taskset.html">Taskset</a></li><li><a href="TaskType.html">TaskType</a></li><li><a href="WoodDoor.html">WoodDoor</a></li><li><a href="WoodDoorLockedBlue.html">WoodDoorLockedBlue</a></li><li><a href="WoodDoorLockedGreen.html">WoodDoorLockedGreen</a></li><li><a href="WoodDoorLockedRed.html">WoodDoorLockedRed</a></li><li><a href="WoodDoorLockedYellow.html">WoodDoorLockedYellow</a></li><li><a href="Workbench.html">Workbench</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#MobStatsList">MobStatsList</a></li><li><a href="global.html#RewardsList">RewardsList</a></li><li><a href="global.html#sendEvent">sendEvent</a></li><li><a href="global.html#taskType">taskType</a></li></ul></div><div class="category"><h2>Corpse</h2><h3>Classes</h3><ul><li><a href="CorpseHuman.html">CorpseHuman</a></li></ul></div><div class="category"><h2>Mob</h2><h3>Classes</h3><ul><li><a href="ArchMage.html">ArchMage</a></li><li><a href="Assassin.html">Assassin</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>entities/destroyables/movables/characters/Player.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const Character = require('./Character');
const checkWebsocketConnectionIsAliveRate = 1000 * 60 * 60;
const wsCheckAge = 1000 * 60 * 60;

class Player extends Character {
    /**
     * @param {Number} config.row
     * @param {Number} config.col
     * @param {Board} config.board
     * @param {Object} config.socket
     */
    constructor (config) {
        super(config);

        config.board.addPlayer(this);

        this.socket = config.socket;

        config.socket.entity = this;

        this.stats = new Statset(this);
        this.tasks = new Taskset(this);
        this.bankAccount = new BankAccount(this);
        this.bornTime = Date.now();

        /**
         * The entrance that this player entity will respawn into.
         * @type {Entrance}
         */
        this.respawnEntrance = config.respawnEntrance || BoardsList.boardsObject["overworld"].entrances["city-spawn"];

        /**
         * This can't be on the prototype, as changing the contents would change it for every instance of this class.
         * @type {{slot1: Item, slot2: Item, slot3: Item, slot4: Item, slot5: Item, slot6: Item, slot7: Item, slot8: Item, slot9: Item, slot0: Item}}
         */
        this.inventory = {
            slot1: null,
            slot2: null,
            slot3: null,
            slot4: null,
            slot5: null,
            slot6: null,
            slot7: null,
            slot8: null,
            slot9: null,
            slot0: null,
        };

        this.nextMoveTime = 0;
        this.isMovePending = false;
        this.pendingMove = {byRows: 0, byCols: 0};

        /** @type {Number} The time after which this player can perform another action. */
        this.nextActionTime = 0;

        // Start the energy regen loop.
        if(this.energyRegenRate !== false){
            //console.log("char enrgy rgn rate: ", this.energyRegenRate);
            this.energyRegenLoop = setTimeout(this.regenEnergy.bind(this), this.energyRegenRate);
        }

        this.connectionCheckTimeout = setTimeout(this.checkWebsocketConnectionIsAlive.bind(this), checkWebsocketConnectionIsAliveRate);

    }

    checkWebsocketConnectionIsAlive () {
        if(this.socket === undefined){
            Utils.warning("Checking player entity websocket connection, is undefined.");
            this.destroy();
            return;
        }
        if(this.socket === null){
            Utils.warning("Checking player entity websocket connection, is null.");
            this.destroy();
            return;
        }
        if(this.socket.entity !== this){
            Utils.warning("Checking player entity websocket connection, entity is not this.");
            this.destroy();
            return;
        }
        // Only print for entities that have been around for a while.
        if(this.bornTime > Date.now() + wsCheckAge){
            console.log("* Connection is still alive for:", this.id, ", dn:", this.displayName);
        }
        this.connectionCheckTimeout = setTimeout(this.checkWebsocketConnectionIsAlive.bind(this), checkWebsocketConnectionIsAliveRate);
    }

    onDestroy () {
        /** @type {Item} */
        let item;

        // Drop all items in inventory.
        // Don't need to check the board tile to drop on, as
        // if they player is already stood on it, it is valid.
        for(let slotKey in this.inventory){
            if(this.inventory.hasOwnProperty(slotKey) === false) continue;
            item = this.inventory[slotKey];
            // Check the item slot is valid, and not empty.
            if(item === null) continue;
            // Add a pickup entity of that item to the board.
            item.drop();
        }

        this.board.removePlayer(this);

        super.onDestroy();
    }

    /**
     * Special function for players, so the inventory isn't dropped when they close the game, otherwise the inventory would be saved and also dropped so would duplicate items.
     * Called in World.removePlayer when the client is closed (by user or timeout, etc.).
     */
    remove () {
        this.board.removePlayer(this);

        if(this.clan !== null){
            this.clan.memberLeft(this);
            this.clan = null;
        }

        clearTimeout(this.connectionCheckTimeout);

        // Call Destroyable.onDestroy directly, without going through the whole
        // onDestroy chain, so skips Player.onDestroy (no duplicate dropped items).
        super.onDestroy();
    }

    getEmittableProperties (properties) {
        if(this.clothing !== null) properties.clothingTypeNumber = this.clothing.typeNumber;
        return super.getEmittableProperties(properties);
    }

    /**
     * Returns all of the items in the player's inventory, in a form that is ready to be emitted.
     * @returns {Array}
     */
    getEmittableInventory () {
        let emittableInventory = [];
        let item;

        for(let slotKey in this.inventory){
            if(this.inventory.hasOwnProperty(slotKey) === false) continue;
            // Skip empty slots.
            if(this.inventory[slotKey] === null) continue;
            item = this.inventory[slotKey];
            emittableInventory.push({typeNumber: item.typeNumber, slotKey: item.slotKey, durability: item.durability, maxDurability: item.maxDurability});
        }

        return emittableInventory;
    }

    respawn () {
        this.hitPoints = this.maxHitPoints;
        this.energy = this.maxEnergy;
        // Players are a special case that can be undestroyed.
        this._destroyed = false;
        this.regenEnergy();

        // Reposition them to somewhere within the respawn entrance bounds.
        let position = this.respawnEntrance.getRandomPosition();
        this.changeBoard(this.respawnEntrance.board, position.row, position.col);

        this.socket.sendEvent(this.EventsList.player_respawn);
    }

    regenEnergy () {
        //console.log("regenning energy character: ", this.energy);
        if(this.energy &lt; this.maxEnergy){
            this.modEnergy(+1);
        }
        this.energyRegenLoop = setTimeout(this.regenEnergy.bind(this), this.energyRegenRate);
    }

    reposition (toRow, toCol) {
        this.board.removePlayer(this);
        super.reposition(toRow, toCol);
        this.board.addPlayer(this);
    }

    move (byRows, byCols) {

        // Check if this player can move yet.
        if(Date.now() &lt; this.nextMoveTime){
            // Can't move yet. Make this move command be pending, so it happens as soon as it can.

            clearTimeout(this.pendingMove);

            this.pendingMove = setTimeout(this.move.bind(this), this.nextMoveTime - Date.now(), byRows, byCols);

            return;
        }

        this.nextMoveTime = Date.now() + this.moveDelay;

        // Check if the entity can move as a character.
        if(super.move(byRows, byCols) === true){

            let dynamicsAtViewRangeData = this.board.getDynamicsAtViewRangeData(this.row, this.col, this.direction);

            // Don't bother sending the event if no dynamics were found.
            if(dynamicsAtViewRangeData !== false){
                // Tell the player any dynamics that they can now see in the direction they moved.
                this.socket.sendEvent(
                    this.EventsList.add_entities,
                    dynamicsAtViewRangeData
                );
            }

        }
    }

    push (byRows, byCols) {
        // Don't let this player be pushed if they are in a safe zone.
        if(this.isInSafeZone() === false){
            super.push(byRows, byCols);
        }
    }

    /**
     * Gets whether this player is in a safe zone.
     * @returns {Boolean}
     */
    isInSafeZone () {
        return this.board.grid[this.row][this.col].safeZone;
    }

    /**
     * Limits the rate that a player can perform actions.
     * @param {Function} action - A function of the thing to do, such as use the held item.
     * @param {Object} context - The context to run the action in. Usually an entity or item.
     * @param {Object} config - Any additional inputs that the action requires.
     */
    performAction (action, context, config) {
        if(Date.now() > this.nextActionTime){
            this.nextActionTime = Date.now() + 500;
            action.call(context, config);
        }
    }

    /**
     * @param {Number} amount
     * @param {Entity} damagedBy
     */
    damage (amount, damagedBy) {
        if(damagedBy !== undefined &amp;&amp; damagedBy !== null){
            // If damaged by another player in a safe zone, ignore the damage.
            if(damagedBy instanceof Player){
                if(this.isInSafeZone() === true) return;
            }
            // If damaged by something that has a player controlling it in a safe zone, ignore the damage.
            if(damagedBy.master instanceof Player){
                if(this.isInSafeZone() === true) return;
            }
        }
        // Damage any clothes being worn.
        if(this.clothing !== null){
            this.clothing.modDurability(-Math.floor(amount * 0.25));
        }

        super.damage(amount, damagedBy);
    }

    /**
     * Move this entity from the current board to another one.
     * @param {Board} toBoard - The board to move the entity to.
     * @param {Number} toRow - The board grid row to reposition the entity to.
     * @param {Number} toCol - The board grid col to reposition the entity to.
     */
    changeBoard (toBoard, toRow, toCol) {

        this.board.removePlayer(this);

        super.changeBoard(toBoard, toRow, toCol);

        this.board.addPlayer(this);

        // Tell the client to load the new board map.
        this.socket.sendEvent(this.EventsList.change_board, {
            boardName: this.board.name,
            boardAlwaysNight: this.board.alwaysNight,
            playerRow: this.row,
            playerCol: this.col,
            dynamicsData: this.board.getNearbyDynamicsData(this.row, this.col)
        });
    }

    modGlory (amount) {
        this.glory += amount;
        // Tell the player their new glory amount.
        this.socket.sendEvent(this.EventsList.glory_value, this.glory);
    }

    modBounty (amount) {
        this.bounty += amount;
        // Tell the player their new bounty amount.
        this.socket.sendEvent(this.EventsList.bounty_value, this.bounty);
    }

    modHitPoints (amount, source) {
        // If damaged by another player in a safe zone, ignore the damage.
        if(source instanceof Player){
            if(this.board.grid[this.row][this.col].safeZone === true){
                return;
            }
        }
        super.modHitPoints(amount);
        // Tell the player their new HP amount.
        this.socket.sendEvent(this.EventsList.hit_point_value, this.hitPoints);
    }

    modEnergy (amount) {
        this.energy += amount;

        // Make sure they can't go above max energy.
        if(this.energy > this.maxEnergy){
            this.energy = this.maxEnergy;
        }

        // Tell the player their new energy amount.
        this.socket.sendEvent(this.EventsList.energy_value, this.energy);
    }

    modDefence (amount) {
        super.modDefence(amount);
        // Tell the player their new defence amount.
        this.socket.sendEvent(this.EventsList.defence_value, this.defence);
    }

    /**
     * @param {Clothes} clothing
     */
    modClothing (clothing) {
        if(clothing === null){
            // Tell the player to hide the equip icon on the inventory slot of the item that was removed.
            this.socket.sendEvent(this.EventsList.deactivate_clothing, this.clothing.slotKey);

            for(let statKey in this.clothing.statBonuses){
                if(this.clothing.statBonuses.hasOwnProperty(statKey) === false) continue;

                this.stats[statKey].levelModifier -= this.clothing.statBonuses[statKey];
            }
        }
        else {
            // Tell the player to show the equip icon on the inventory slot of the item that was equipped.
            this.socket.sendEvent(this.EventsList.activate_clothing, clothing.slotKey);

            for(let statKey in clothing.statBonuses){
                if(clothing.statBonuses.hasOwnProperty(statKey) === false) continue;

                this.stats[statKey].levelModifier += clothing.statBonuses[statKey];
            }
        }
        // Do this after, or this.clothing would have already been nulled, so won't have a slot key to send to the client.
        this.clothing = clothing;
    }

    /**
     * @param {Holdable} holding
     */
    modHolding (holding) {
        if(holding === null){
            // Tell the player to hide the equip icon on the inventory slot of the item that was removed.
            this.socket.sendEvent(this.EventsList.deactivate_holding, this.holding.slotKey);
        }
        else {
            // Tell the player to show the equip icon on the inventory slot of the item that was equipped.
            this.socket.sendEvent(this.EventsList.activate_holding, holding.slotKey);
        }
        // Do this after, or this.holding would have already been nulled, so won't have a slot key to send to the client.
        this.holding = holding;
    }

    /**
     * @param {Ammunition} ammunition
     */
    modAmmunition (ammunition) {
        if(ammunition === null){
            // Tell the player to hide the ammunition icon on the inventory slot of the item that was removed.
            this.socket.sendEvent(this.EventsList.deactivate_ammunition, this.ammunition.slotKey);
        }
        else {
            // Tell the player to show the ammunition icon on the inventory slot of the item that was equipped.
            this.socket.sendEvent(this.EventsList.activate_ammunition, ammunition.slotKey);
        }
        // Do this after, or this.ammunition would have already been nulled, so won't have a slot key to send to the client.
        this.ammunition = ammunition;
    }

    /**
     * Add an item to the inventory of this player.
     * @param {Item} item - The item instance to add to the inventory.
     * @param {String} [slotKey] - A specific slot to add the item at. Must be an empty (null) slot or throws error. Should be used after Player.isInventoryFull. Leave undefined to use the first empty slot.
     */
    addToInventory (item, slotKey) {
        // If a slot key to add at was given, use it.
        if(slotKey !== undefined){
            // Check that slot is empty. Throw an error if it is occupied. Also catches the case that an invalid slot key was given (i.e. 'abcd').
            if(this.inventory[slotKey] !== null){
                Utils.error("Attempt to add item to character inventory at already occupied slot: " + slotKey + ", item: " + item.constructor.name);
            }
        }
        // No slot key specified, get the first empty one.
        else {
            slotKey = this.getEmptyInventorySlotKey();
        }

        // Add the item to the character's inventory.
        this.inventory[slotKey] = item;

        // Add the character as the owner of the item.
        item.owner = this;

        // Keep the slot key it is in on the item itself.
        item.slotKey = slotKey;

        //console.log("item added to char inventory at:", slotKey);

        // Tell the player an item was added to their inventory.
        this.socket.sendEvent(this.EventsList.add_item, {typeNumber: item.typeNumber, slotKey: item.slotKey, durability: item.durability, maxDurability: item.maxDurability});
    }

    /**
     * Clears an inventory slot with a given key.
     * @param {String} slotKey
     */
    removeFromInventoryBySlotKey (slotKey) {
        this.inventory[slotKey] = null;
        // Tell the player to remove this item.
        this.socket.sendEvent(this.EventsList.remove_item, slotKey);
    }

    /**
     * Swap the contents of two slots. They can be empty or occupied.
     * @param {String} slotKeyFrom
     * @param {String} slotKeyTo
     */
    swapInventorySlots (slotKeyFrom, slotKeyTo) {
        if(this.inventory[slotKeyFrom] === undefined) return;
        if(this.inventory[slotKeyTo] === undefined) return;

        const slotFrom = this.inventory[slotKeyFrom];

        this.inventory[slotKeyFrom] = this.inventory[slotKeyTo];

        this.inventory[slotKeyTo] = slotFrom;

        if(this.inventory[slotKeyTo] !== null){
            this.inventory[slotKeyTo].slotKey = slotKeyTo;
        }
        if(this.inventory[slotKeyFrom] !== null){
            this.inventory[slotKeyFrom].slotKey = slotKeyFrom;
        }
    }

    /**
     * Use the item at the given slot.
     * @param {String} slotKey
     */
    useItem (slotKey) {
        // Check that slot is valid.
        if(this.inventory[slotKey] === undefined) return false;

        this.inventory[slotKey].use();
    }

    /**
     * @static
     */
    pickUpItem () {
        // Get the tile the character is standing on.
        const boardTile = this.board.grid[this.row][this.col];

        let pickup = null;

        // Get the first entity in the pickups list.
        for(let pickupKey in boardTile.pickups){
            if(boardTile.pickups[pickupKey] === undefined) continue;
            pickup = boardTile.pickups[pickupKey];
            break;
        }

        // Check it has a pickup item on it.
        if(pickup === null) return;

        // Check the inventory isn't full.
        if(this.isInventoryFull() === true) return;

        // Get the first empty inventory slot.
        this.addToInventory(new pickup.ItemType({durability: pickup.durability, maxDurability: pickup.maxDurability}));

        pickup.destroy();
    }

    /**
     * Get the key of the first empty slot in the inventory.
     * Throws an error if no slots are empty. Should be used after Player.isInventoryFull.
     * @return {String}
     */
    getEmptyInventorySlotKey () {
        for(let slotKey in this.inventory){
            if(this.inventory.hasOwnProperty(slotKey) === false) continue;
            // If an empty slot is found, return the key for it.
            if(this.inventory[slotKey] === null) {
                //console.log("empty slot key:", slotKey);
                return slotKey;
            }
        }
        // All slots are occupied. Throw an error.
        Utils.error("getEmptyInventorySlotKey, no inventory slots are empty. Should use Player.isInventoryFull before to check if a slot is empty.");
    }

    /**
     * Returns whether the inventory is full (all slots occupied).
     * @return {Boolean}
     */
    isInventoryFull () {
        // Check that the character that interacted with this node has space in their inventory.
        for(let slot in this.inventory){
            if(this.inventory.hasOwnProperty(slot) === false) continue;
            // If an empty slot is found, stop looping.
            if(this.inventory[slot] === null) return false;
        }
        // All slot are occupied. Inventory is full.
        // Tell the player.
        this.socket.sendEvent(this.EventsList.inventory_full);

        return true;
    }

    /**
     * Clears the first inventory slot found that contains an instance of the specified class.
     * @param {Function} Item - The class to check for instances of. NOT an instance of the class.
     */
    removeFromInventoryByItemType (Item) {
        for(let slot in this.inventory){
            if(this.inventory.hasOwnProperty(slot) === false) continue;
            if(this.inventory[slot] instanceof Item){
                this.inventory[slot].destroy();
                // Item type was found and removed.
                return true;
            }
        }
        // No item of the given type was found.
        return false;
    }

}
module.exports = Player;

// Need to define the references to the sub-classes that are used by methods here AFTER the class is exported, otherwise the class doesn't exist yet for them to extend from.
// Same reason for all other classes.
const Utils = require('../../../../Utils');
const BoardsList = require('../../../../BoardsList');
const BankAccount = require('../../../../BankAccount');
const Statset = require('../../../../stats/Statset');
const Taskset = require('../../../../tasks/Taskset');
const world = require('../../../../World');

Player.prototype.registerEntityType();

// Give each player easy access to the events list.
Player.prototype.ChatWarnings = require('../../../../ChatWarnings');
/** @type {Number} How long between each move. */
Player.prototype.moveDelay = 250;
/** @type {Number} */
Player.prototype.maxHitPoints = 200;
/** @type {Number} */
Player.prototype.hitPoints = Player.prototype.maxHitPoints;
/** @type {Number} */
Player.prototype.maxEnergy = 20;
/** @type {Number} */
Player.prototype.energy = Player.prototype.maxEnergy;
/** @type {Number} */
Player.prototype.energyRegenRate = 1000;
/** @type {Number|null} */
Player.prototype.energyRegenLoop = null;
/** @type {Number} */
Player.prototype.glory = 100;
/** @type {Number} */
Player.prototype.bounty = 0;
/** @type {Function} */
Player.prototype.CorpseType = require('../../corpses/CorpseHuman');

/**
 * What this player is wearing. Such as armour, robes, cloak, disguise, apron.
 * A reference to an item in their inventory.
 * @type {Clothes}
 */
Player.prototype.clothing = null;

/**
 * What this player is holding. Mostly weapons.
 * A reference to an item in their inventory.
 * @type {Holdable}
 */
Player.prototype.holding = null;

/**
 * What this player is using as ammunition. Mostly arrows.
 * A reference to an item in their inventory.
 * @type {Ammunition}
 */
Player.prototype.ammunition = null;

/**
 * The clan this player is in, if they are in one.
 * @type {Clan}
 */
Player.prototype.clan = null;

/** @type {Number} How far can a player entity see, and how much data to send to their client. */
Player.viewRange = 15;</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>


<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Sat Jan 25 2020 01:23:46 GMT+0000 (Greenwich Mean Time)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
        </p>
    </div>
</footer>


<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
